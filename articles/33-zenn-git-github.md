---
id: 33-zenn-what-is-neovim
aliases: []
tags: []
autonotemover: disable
cssclasses:
  - zenn
date: "2025-07-17"
published: false
title: Neovimとは
type: tech
url: https://zenn.dev/thirdlf/articles/33-zenn-git-github.md
---


# Gitとは
Gitとは、プログラムのソースコードなどの変更履歴を記録・追跡するための分散型バージョン管理システム。
https://ja.wikipedia.org/wiki/Git

他には、SVNとかBitBucketなど色々バージョン管理ツールはあるが、最近はgitが流行っている。

# GitHubとは
GitHubは、ソフトウェア開発のプラットフォームであり、ソースコードをホスティングする。コードのバージョン管理システムにはGitを使用する。
https://ja.wikipedia.org/wiki/GitHub


# GitとGitHub違い
Gitは、コードのバージョン管理のためのツールで、GitHubはプラットフォーム！！！
大事です


# ハンズオン形式でGitの用語を覚えよう！
gitの用語をハンズオンしながら勉強していこう！

## まずはGitのインストール
何はともあれGitをインストールしましょう！

### Windows 
ここを参照
https://prog-8.com/docs/git-env-win


### Mac
ここを参照
https://prog-8.com/docs/git-env

Xcode環境がある人はGitが入っていると思いますが、入っていない場合はHomebrew経由でインストールするのがおすすめです。

Homebrew インストール
```bash
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

```bash
brew install git
```

## リポジトリ
プロジェクトのファイルやフォルダ、そしてそれらの変更履歴すべてを保存しておく場所です。

特定のフォルダをリポジトリにするには、リポジトリにしたいフォルダに移動して
```
cd リポジトリにしたいフォルダ名
git init
```
とすることで、リポジトリになります

### リモートとローカルリポジトリ
手元のPCにあるリポジトリをローカルリポジトリ、GitHubなど自分の手元以外にあるリポジトリをリモートリポジトリと呼びます。

基本はローカルリポジトリで作業をした後、その内容をリモートリポジトリに反映させるって形になります。

## Gitの基本的な開発の流れ

実際の開発では、以下のような流れでGitを使います：

### 1. プロジェクトを始める
- 既存のプロジェクトに参加する場合：`git clone`でリモートリポジトリをローカルに複製
- 新しくプロジェクトを始める場合：`git init`でローカルリポジトリを作成

### 2. 日常的な開発作業
1. **最新の変更を取得**：`git pull`で他の人の変更を取り込む
2. **ファイルを編集**：コードを書いたり、ファイルを修正
3. **変更をステージング**：`git add`で変更したファイルを「コミット準備エリア」に移動
4. **変更を記録**：`git commit`で変更を正式にリポジトリに保存
5. **リモートに送信**：`git push`で自分の変更を他の人と共有

### 3. Gitの3つのエリア
Gitには3つの重要なエリアがあります：

- **作業ディレクトリ**：実際にファイルを編集する場所（あなたのPCのフォルダ）
- **ステージングエリア**：コミットする準備ができた変更を一時的に置く場所
- **リポジトリ**：変更が正式に記録される場所

```
作業ディレクトリ → ステージングエリア → リポジトリ
    (編集)       git add      git commit
```

なぜこのような手順になっているかというと、**一度に全ての変更をコミットするのではなく、関連する変更だけを選んでコミットできる**からです。

例えば、バグ修正と新機能を同時に作業していた場合、それぞれを別々のコミットとして記録できます。

## クローン (clone)

### いつ使う？
- 新しいプロジェクトに参加する時
- 既存のオープンソースプロジェクトを使いたい時
- 他の人のコードを見たい時

### どういう機能？
cloneを使うと、リモートリポジトリの情報を参照して、リモートリポジトリと同じようのローカルリポジトリを作ることができます。

### 実際の使い方
```bash
git clone url
```

例えば、GitHubにあるプロジェクトを自分のPCに持ってくる時に使います：

```bash
git clone https://github.com/username/repository-name.git
```

### 具体例：初めてプロジェクトに参加する場合
1. チームリーダーからGitHubのリポジトリURLをもらう
2. ターミナルで作業したいフォルダに移動
3. `git clone URL`でプロジェクト全体を自分のPCにコピー
4. プロジェクトフォルダに移動して開発開始

## ステージング (add)

### いつ使う？
- ファイルを編集した後、その変更をコミットしたい時
- 新しくファイルを作成した時
- 複数の変更の中から、特定の変更だけをコミットしたい時

### なぜ必要？
ファイルを編集しただけでは、まだGitに「この変更をコミットしたい」と伝えていません。addすることで「この変更をコミットする準備ができました」とGitに伝えます。

これにより、**関連する変更だけを選んでコミット**できます。

### 実際の使い方
特定のファイルをステージングする場合：
```bash
git add ファイル名
```

すべてのファイルを一度にaddする場合：
```bash
git add .
```

現在のステージング状況を確認するには：
```bash
git status
```

### 具体例：バグ修正と新機能を同時に作業している場合
```bash
# 状況：bug.jsを修正し、newfeature.jsを新規作成した

git status
# 結果：
# modified: bug.js
# untracked: newfeature.js

# バグ修正だけを先にコミットしたい場合
git add bug.js
git commit -m "バグを修正"

# 後で新機能もコミット
git add newfeature.js
git commit -m "新機能を追加"
```

## コミット (commit)

### いつ使う？
- ステージングした変更を正式に記録したい時
- 作業がひと段落ついた時
- 他の人と変更を共有する前

### どういう機能？
ステージングエリアにある変更を、リポジトリに正式に記録することをコミットと呼びます。コミットすると、その時点のスナップショットが保存されます。

### 実際の使い方
```bash
git commit -m "コミットメッセージ"
```

### 良いコミットメッセージの書き方
コミットメッセージは「なぜその変更をしたのか」を書きます：

**良い例：**
- "ログイン機能を追加"
- "バグを修正: ユーザー登録時のエラー処理"
- "パフォーマンス改善: 画像の遅延読み込みを実装"

**悪い例：**
- "修正"
- "変更"
- "update"

### 具体例：機能開発の流れ
```bash
# ログイン画面を作成
git add login.html
git commit -m "ログイン画面のHTMLを作成"

# CSSを追加
git add login.css
git commit -m "ログイン画面のスタイルを追加"

# JavaScriptの処理を追加
git add login.js
git commit -m "ログイン処理のJavaScriptを実装"
```

このように、小さな単位でコミットすると、後で変更履歴を見た時に何をしたかがわかりやすくなります。

## プル (pull)

### いつ使う？
- 作業を始める前（必須！）
- 他の人がコードを更新したと聞いた時
- 自分の変更をpushする前

### なぜ必要？
チーム開発では、複数の人が同じプロジェクトで作業しています。他の人が新しい機能を追加したり、バグを修正している間に、あなたも別の作業をしているかもしれません。

pullすることで、**他の人の最新の変更を自分のPCに取り込んで、同じ状態で作業**できます。

### 実際の使い方
```bash
git pull
```

### 具体例：チーム開発での典型的な1日
```bash
# 朝、作業を始める前
git pull
# → 昨日同僚が修正したバグフィックスを取得

# 自分の作業をする
git add .
git commit -m "新しい機能を追加"

# ランチ後、再び作業を始める前
git pull
# → 午前中に同僚が追加した新機能を取得

# 自分の変更をリモートに送信
git push
```

### よくある問題とその解決
**問題：** pullを忘れて作業してしまった
```bash
git pull
# → エラー：コンフリクトが発生

# 解決方法：
# 1. コンフリクトしたファイルを手動で修正
# 2. 修正後にadd & commit
git add .
git commit -m "コンフリクトを解決"
```

## ブランチ (Branch)

### いつ使う？
- 新しい機能を開発する時
- バグを修正する時
- 実験的な変更を試したい時
- 複数の人が同時に違う作業をする時

### なぜ必要？
ブランチを使うことで、**メインのコードを壊すことなく、安全に新しい機能を開発**できます。

例えば、ログイン機能を開発している間も、他の人は別の機能を開発し続けることができます。

### 実際の使い方
現在のブランチを確認：
```bash
git branch
```

新しいブランチを作成：
```bash
git branch ブランチ名
```

ブランチを切り替え：
```bash
git checkout ブランチ名
```

新しいブランチを作成して同時に切り替え：
```bash
git checkout -b ブランチ名
```

### 具体例：ログイン機能を開発する場合
```bash
# 現在mainブランチにいる状態
git branch
# * main

# ログイン機能用のブランチを作成して切り替え
git checkout -b feature-login
# → feature-loginブランチに移動

# ログイン機能を開発
# login.html, login.css, login.jsを作成・編集

git add .
git commit -m "ログイン機能を実装"

# 開発完了後、mainブランチに戻る
git checkout main

# この時点で、login関連のファイルは見えない
# （feature-loginブランチにだけ存在）
```

### ブランチ名の命名例
- `feature-login` - ログイン機能
- `fix-header-bug` - ヘッダーのバグ修正
- `update-readme` - READMEの更新

## マージ (merge)

### いつ使う？
- 機能開発が完了して、メインブランチに統合したい時
- バグ修正が完了して、本体に反映したい時
- 複数のブランチの変更を一つにまとめたい時

### どういう機能？
別のブランチの変更を、現在のブランチに統合することをマージと呼びます。これにより、分岐して開発していた機能を本体に取り込むことができます。

### 実際の使い方
```bash
git merge ブランチ名
```

### 具体例：ログイン機能をメインに統合
```bash
# feature-loginブランチで開発完了
git checkout feature-login
git add .
git commit -m "ログイン機能の最終調整"

# mainブランチに切り替え
git checkout main

# 最新の状態にする
git pull

# feature-loginブランチをmainに統合
git merge feature-login

# 統合完了！login機能がmainブランチに追加された
```

### マージ後の片付け
統合が完了したブランチは削除できます：
```bash
# ローカルブランチを削除
git branch -d feature-login

# リモートブランチも削除する場合
git push origin --delete feature-login
```

### 注意：コンフリクトが発生した場合
同じファイルの同じ箇所を複数の人が編集していた場合、コンフリクト（競合）が発生することがあります。この場合は手動で修正が必要です。

## スタッシュ (stash)

### いつ使う？
- 作業途中で急遽別のブランチに切り替える必要がある時
- 作業途中でpullしたい時
- 一時的に変更を取り消したい時

### どういう機能？
作業中の変更を一時的に保存して、作業ディレクトリをクリーンにする機能です。「一時保存」のようなイメージです。

### 実際の使い方
変更を一時保存：
```bash
git stash
```

保存した変更を復元：
```bash
git stash pop
```

stashした内容を確認：
```bash
git stash list
```

### 具体例：緊急のバグ修正が入った場合
```bash
# 新機能を開発中（まだ完成していない）
# index.htmlを編集している途中...

# 突然「緊急のバグがあるから修正して！」と言われた

# 現在の作業を一時保存
git stash
# → 作業ディレクトリがクリーンになる

# バグ修正用ブランチに切り替え
git checkout -b fix-urgent-bug

# バグを修正してコミット
git add .
git commit -m "緊急バグを修正"

# 元のブランチに戻る
git checkout feature-new-function

# 一時保存していた作業を復元
git stash pop
# → 元の作業状態に戻る
```

## リベース (rebase)

### いつ使う？（上級者向け）
- コミット履歴をきれいに整理したい時
- 複数の小さなコミットを一つにまとめたい時
- マージコミットを作らずにブランチを統合したい時

### どういう機能？
ブランチの分岐点を変更して、コミット履歴をきれいに整理する機能です。マージとは違い、履歴が一直線になります。

### 実際の使い方
```bash
git rebase ブランチ名
```

### 初心者への注意
**⚠️ 重要な注意事項 ⚠️**
- リベースは履歴を書き換える危険な操作です
- 他の人と共有しているブランチでは絶対に使わないでください
- 慣れないうちは、基本的に**マージを使うことをおすすめ**します
- チームで作業している場合は、チームのルールに従いましょう

### マージとリベースの違い
**マージの場合：**
```
* マージコミット
|\
| * 機能Aのコミット
|/
* メインのコミット
```

**リベースの場合：**
```
* 機能Aのコミット
* メインのコミット
```

リベースの方が履歴がシンプルになりますが、操作が複雑で間違いやすいため、**初心者はマージから覚えましょう**。



# チームで活用例


## GitHub Flow

## やりがちなミス

